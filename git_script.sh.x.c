#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f git_script.sh -o git_script 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\320"
#define      rlax_z	1
#define      rlax	((&data[1]))
	"\140"
#define      text_z	1696
#define      text	((&data[211]))
	"\341\316\234\262\075\365\374\202\360\257\132\001\207\346\047\350"
	"\224\217\226\173\333\101\350\124\132\242\026\110\166\224\067\127"
	"\142\323\011\240\311\006\043\272\266\175\273\076\143\342\046\370"
	"\162\275\163\116\376\134\242\131\376\270\241\164\115\331\313\260"
	"\255\325\120\166\334\164\060\222\361\354\320\125\317\367\115\101"
	"\264\301\220\263\035\062\014\033\353\256\220\070\210\133\350\065"
	"\061\071\254\016\255\334\240\237\310\161\364\227\150\102\331\035"
	"\003\151\320\040\234\335\074\207\213\315\277\024\051\250\111\132"
	"\341\365\150\216\322\011\055\233\173\042\063\343\144\014\000\150"
	"\166\321\211\022\256\306\232\071\223\132\116\274\002\227\026\343"
	"\215\177\162\140\211\240\373\004\302\056\350\047\073\350\220\261"
	"\272\031\304\150\337\137\242\162\271\360\057\273\207\106\236\025"
	"\305\021\165\116\261\161\123\163\237\073\233\333\044\053\214\336"
	"\104\201\173\355\220\017\271\252\177\011\350\336\375\041\232\217"
	"\142\367\061\061\027\207\065\350\343\352\200\350\346\301\036\334"
	"\227\333\232\370\135\300\011\360\245\211\141\331\126\301\317\104"
	"\165\235\367\205\233\236\263\141\303\317\317\007\211\322\262\251"
	"\047\371\076\132\020\062\136\242\374\100\040\335\073\264\343\126"
	"\110\322\231\351\004\102\273\361\125\005\126\342\244\323\371\363"
	"\314\272\037\324\360\113\130\356\201\372\355\020\135\327\343\262"
	"\155\164\312\136\033\043\300\055\062\223\341\240\231\073\146\324"
	"\266\341\377\220\337\307\125\276\007\240\212\230\025\357\216\223"
	"\070\302\053\157\153\351\113\222\027\241\265\161\125\377\336\043"
	"\076\063\071\155\327\137\141\363\221\365\315\162\217\220\244\206"
	"\073\202\242\300\251\262\074\330\233\212\327\265\365\275\343\220"
	"\217\156\363\355\317\307\356\143\261\053\207\275\070\334\001\241"
	"\312\252\024\225\061\261\160\057\367\331\304\242\222\045\107\144"
	"\324\120\364\366\311\147\120\341\314\153\366\205\273\300\357\215"
	"\230\306\231\030\372\113\132\153\353\163\342\321\325\304\222\035"
	"\125\077\041\146\112\314\035\341\121\071\365\041\304\265\217\156"
	"\146\134\037\035\240\065\375\267\041\301\302\204\157\121\054\361"
	"\035\211\075\105\244\315\123\023\066\267\011\247\352\123\227\223"
	"\040\264\323\120\141\267\245\346\304\203\045\053\134\151\361\135"
	"\010\261\302\345\026\242\342\301\332\037\141\036\132\126\222\067"
	"\352\262\052\143\177\136\052\230\052\250\230\234\335\140\363\161"
	"\025\151\141\243\337\013\214\017\337\125\076\253\211\167\122\232"
	"\172\167\064\271\214\316\340\314\365\335\024\103\042\353\266\351"
	"\314\136\120\354\035\363\022\175\100\156\115\206\031\013\332\077"
	"\007\056\264\171\107\115\334\377\325\253\312\032\245\126\303\273"
	"\064\035\352\133\124\146\172\071\331\167\122\247\271\344\015\132"
	"\200\225\214\245\141\134\007\125\260\114\275\241\212\265\001\366"
	"\055\321\007\361\215\207\144\267\104\305\077\254\027\010\365\103"
	"\211\217\105\157\011\342\151\176\127\065\166\307\053\260\264\370"
	"\003\351\336\167\305\070\255\021\212\266\136\247\232\156\104\021"
	"\350\211\175\271\276\243\330\351\244\211\041\125\007\055\104\135"
	"\163\041\252\216\010\367\377\052\052\005\064\123\035\271\074\376"
	"\164\067\117\323\050\254\006\077\120\261\215\042\356\233\350\312"
	"\023\160\302\214\305\236\144\231\307\001\054\253\156\175\022\371"
	"\262\260\140\113\030\013\033\273\057\217\332\007\140\052\001\252"
	"\152\241\341\142\145\324\013\063\300\255\073\076\205\120\053\355"
	"\120\322\245\013\315\005\257\367\162\202\274\064\135\366\152\001"
	"\173\167\076\371\077\165\231\103\153\100\056\151\111\104\002\230"
	"\314\136\160\147\263\342\060\247\073\120\076\237\357\045\331\054"
	"\273\253\310\120\270\025\307\143\242\245\273\262\333\263\240\050"
	"\105\325\025\112\270\164\107\072\124\032\171\341\146\270\153\004"
	"\153\113\376\124\155\056\001\356\155\121\161\114\172\232\343\050"
	"\307\022\263\057\062\264\065\221\301\043\071\254\043\115\112\305"
	"\123\157\041\131\275\104\350\340\371\220\011\110\316\240\264\176"
	"\204\362\252\260\371\021\234\145\321\005\070\023\143\075\340\236"
	"\326\201\004\367\306\124\313\014\311\151\030\052\113\337\156\141"
	"\206\110\171\022\261\370\324\152\222\102\373\271\333\265\306\031"
	"\366\221\127\067\114\243\231\160\235\022\157\253\152\364\355\176"
	"\326\371\022\104\152\256\233\150\163\200\262\331\162\162\322\047"
	"\201\206\355\365\367\044\124\360\030\046\037\264\273\053\135\146"
	"\073\142\243\351\066\245\363\030\125\201\251\342\056\026\161\123"
	"\310\165\160\114\346\214\061\112\243\332\140\367\023\010\012\166"
	"\222\103\340\244\252\144\130\324\331\103\334\302\055\245\021\243"
	"\225\046\013\045\365\212\004\156\321\334\013\217\077\101\045\164"
	"\013\014\045\350\340\123\221\276\206\024\073\333\033\132\025\050"
	"\174\372\204\207\353\017\126\356\027\101\043\112\357\044\262\204"
	"\217\373\007\176\217\167\350\054\355\067\347\270\343\177\307\307"
	"\135\047\354\315\121\264\037\101\305\037\330\063\053\261\205\273"
	"\073\007\377\216\132\351\100\110\327\235\354\163\301\346\324\010"
	"\312\365\375\345\010\135\024\232\007\112\146\300\077\162\167\070"
	"\342\162\056\131\033\320\333\265\250\035\054\213\253\360\176\177"
	"\131\233\006\142\004\242\060\162\264\361\023\024\204\213\355\071"
	"\130\067\151\116\106\051\010\061\053\060\347\004\335\372\362\301"
	"\004\016\055\055\017\235\161\355\337\230\342\110\120\202\321\105"
	"\027\232\056\156\203\077\111\142\327\331\010\155\065\213\267\131"
	"\033\120\307\071\120\174\317\104\255\353\130\165\265\023\276\340"
	"\255\050\017\163\257\270\015\074\224\152\174\347\064\376\062\234"
	"\117\043\156\323\145\176\335\125\235\251\205\007\272\147\257\240"
	"\301\153\144\207\116\315\110\202\143\073\073\265\371\152\354\162"
	"\034\117\135\222\131\024\005\367\322\140\061\216\026\161\014\276"
	"\326\375\202\332\030\345\165\113\304\275\246\270\275\006\110\073"
	"\073\215\150\214\141\130\341\036\170\034\360\250\206\107\255\253"
	"\042\162\115\360\047\072\165\240\060\060\323\200\104\162\224\044"
	"\306\012\141\304\223\075\074\102\115\007\053\240\274\071\351\125"
	"\376\324\104\140\300\063\257\047\244\174\050\300\352\234\266\012"
	"\305\351\341\043\260\274\102\155\200\161\047\233\271\057\300\026"
	"\377\073\207\120\064\336\000\044\014\131\251\313\024\226\062\314"
	"\137\143\125\234\264\240\116\375\262\253\332\300\371\116\352\201"
	"\265\274\276\170\076\335\031\324\370\325\234\126\125\064\242\122"
	"\215\246\340\362\311\232\006\321\263\311\343\213\372\117\145\255"
	"\071\050\072\033\116\114\055\006\064\313\353\252\305\015\175\345"
	"\066\266\301\362\346\264\151\333\101\221\151\200\021\270\203\064"
	"\256\347\107\106\067\011\057\144\207\271\337\370\332\235\002\363"
	"\247\215\203\223\114\324\243\316\234\370\066\026\331\302\240\120"
	"\244\047\323\051\072\016\043\161\115\215\062\124\031\073\252\256"
	"\022\013\153\264\356\273\361\243\300\173\073\105\213\261\136\175"
	"\132\001\343\032\141\172\300\252\223\261\126\376\124\246\320\236"
	"\153\244\177\117\360\021\271\064\202\036\042\276\354\121\073\004"
	"\314\111\227\304\132\331\322\237\234\133\252\303\322\230\225\302"
	"\377\125\350\340\152\317\227\376\207\006\306\160\372\147\075\011"
	"\307\315\134\253\144\177\324\256\343\360\241\227\160\275\230\364"
	"\224\116\056\105\270\172\223\014\215\041\272\032\312\151\113\207"
	"\061\006\375\251\233\244\004\004\376\031\026\215\332\120\214\324"
	"\253\361\103\222\216\036\117\153\077\005\233\071\047\125\240\132"
	"\264\234\250\074\305\074\371\240\367\144\352\100\306\134\221\136"
	"\063\244\054\213\143\326\035\301\030\055\242\336\175\164\310\315"
	"\145\233\013\172\037\034\317\274\062\362\231\122\246\362\101\015"
	"\143\306\351\076\362\106\013\164\374\053\010\062\365\303\007\271"
	"\170\030\313\102\034\364\067\113\327\312\055\144\167\014\143\371"
	"\305\201\041\044\355\313\034\113\037\071\232\134\323\036\045\253"
	"\227\323\327\356\167\161\251\107\305\175\221\353\162\027\071\216"
	"\250\035\372\377\337\040\154\001\062\066\004\276\177\221\157\264"
	"\130\055\373\054\347\206\075\146\103\111\364\227\053\003\164\211"
	"\077\074\164\353\345\161\210\105\235\002\322\065\014\067\156\353"
	"\220\317\245\133\327\001\361\346\275\060\047\357\364\124\050\017"
	"\146\121\106\044\260\350\227\151\330\306\045\140\014\303\166\322"
	"\325\353\041\206\134\164\372\374\257\225\327\324\300\144\262\005"
	"\266\370\051\146\340\301\320\271\210\365\031\225\271\217\147\216"
	"\173\211\024\330\376\016\325\255\244\254\201\144\021\064\152\307"
	"\054\224\055\015\125\376\307\335\363\341\163\254\161\332\073\355"
	"\144\120\305\142\136\232\020\003\107\222\147\130\306\322\037\363"
	"\146\115\001\274\114\310\232\077\251\015\354\033\350\047\010\114"
	"\170\315\257\327\150\277\332\260\122\102\010\030\024\050\014\173"
	"\166\015\067\302\326\322\002\200\337\356\233\310\026\243\025\216"
	"\161\304\145\332\204\100\212\326\202\223\357\226\274\373\021\062"
	"\011\111\365\337\033\367\137\373\346\373\303\375\237\330\214\020"
	"\235\362\352\041\062\165\370\264\010\347\113\304\343\135\367\355"
	"\246\355\314\302\345\054\275\313\050\201\311\307\132\125\327\370"
	"\107\302\031\172\070\022\056\100\372\171\005\336\326\375\313\175"
	"\353\230\077\320\304\375\233\355\177\145\264\331\272\214\321\002"
	"\117\353\174\207\376\253\310\370\045\316\326\374\313\241\171\266"
	"\072\271\207\377\267\042\354\066\210\240\020\102\054\342\105\174"
	"\315\302\003\313\155\313\304\222\231\233\216\145\075\010\034\167"
	"\302\243\166\171\306\142\260\116\003\300\221\060\242\326\254\160"
	"\230\257\074\006\173\000\230\025\234\047\172\331\060\227\120\362"
	"\072\306\153\000\051\034\117\054\334\340\135\177\267\011\360\120"
	"\271\054\126\065\055\357\112\312\026\304\243\106\134\363\071\226"
	"\272\244\227\343\300\346\020\235\306\155\035\176\167\015\316\060"
	"\072\045\145\150\024\257\062\053\164\325\162\320\311\253\147\203"
	"\120\376\146\021\344\167\257\253\344\314\052\133\332\370"
#define      chk1_z	22
#define      chk1	((&data[2304]))
	"\207\122\144\137\111\272\033\214\200\367\314\013\157\244\265\033"
	"\107\224\332\253\115\115"
#define      chk2_z	19
#define      chk2	((&data[2328]))
	"\242\260\356\102\247\073\117\305\217\211\030\075\270\041\106\322"
	"\202\024\347\044\106"
#define      xecc_z	15
#define      xecc	((&data[2347]))
	"\336\250\250\251\354\313\043\235\143\334\320\331\021\255\141\320"
	"\350"
#define      inlo_z	3
#define      inlo	((&data[2364]))
	"\265\354\325"
#define      tst2_z	19
#define      tst2	((&data[2371]))
	"\071\336\062\260\111\035\310\367\046\310\276\006\366\036\301\154"
	"\261\051\010\102\207\263\244\215"
#define      pswd_z	256
#define      pswd	((&data[2428]))
	"\011\361\064\001\175\112\040\157\310\122\021\170\260\051\377\201"
	"\021\116\375\140\041\312\256\133\251\341\014\066\300\241\221\311"
	"\222\305\313\020\020\101\061\147\303\262\020\102\251\035\110\150"
	"\332\170\307\110\265\327\267\001\265\345\035\231\023\042\055\261"
	"\134\256\265\121\357\346\270\263\230\311\366\102\346\076\252\300"
	"\266\162\011\154\111\300\156\376\246\213\230\272\255\306\154\012"
	"\164\041\133\143\007\024\027\240\335\015\342\304\113\215\204\002"
	"\000\215\156\111\116\335\110\365\150\341\257\026\247\033\040\033"
	"\075\174\177\104\220\226\345\156\243\310\063\357\125\267\361\125"
	"\105\140\237\224\075\350\212\246\311\072\275\160\126\336\214\223"
	"\132\013\327\353\242\275\132\106\205\215\065\333\105\047\061\213"
	"\210\320\040\306\271\252\154\202\344\052\363\072\010\177\315\142"
	"\213\245\115\055\142\250\163\350\065\251\303\172\320\364\006\131"
	"\305\046\037\176\320\213\001\264\265\364\357\276\164\275\040\377"
	"\142\156\055\305\026\240\256\114\112\161\307\033\146\315\164\054"
	"\363\223\253\303\037\254\170\325\241\150\223\025\045\263\025\210"
	"\042\102\116\071\343\374\205\055\156\114\110\324\032\274\001\015"
	"\120\254\321\157\131\112\104\373\262\327\020\330\213\045\140\256"
	"\150\256\347\113\252\353\177\330\076\221\120\357\273\120\160\314"
	"\237\156\054\301\071\333\034\342\275\051\031"
#define      tst1_z	22
#define      tst1	((&data[2710]))
	"\106\135\160\022\220\056\335\275\204\041\051\004\027\300\011\020"
	"\125\312\173\171\251\217\061\056\040\121\155\200\375\355"
#define      msg2_z	19
#define      msg2	((&data[2737]))
	"\251\014\110\006\036\276\022\307\366\366\313\240\075\205\345\056"
	"\151\323\067\365\052\072"
#define      msg1_z	65
#define      msg1	((&data[2768]))
	"\231\012\063\132\103\017\166\046\314\240\163\264\370\250\210\042"
	"\215\037\052\007\104\011\342\267\143\166\060\056\227\006\353\205"
	"\020\322\055\140\310\214\072\174\106\132\022\225\145\175\044\372"
	"\165\153\235\164\042\274\304\035\371\346\203\300\325\363\346\315"
	"\201\060\250\243\110\173\115\025\147\041\232"
#define      shll_z	10
#define      shll	((&data[2833]))
	"\333\326\233\160\275\313\106\347\266\137\353"
#define      opts_z	1
#define      opts	((&data[2844]))
	"\027"
#define      date_z	1
#define      date	((&data[2845]))
	"\356"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
